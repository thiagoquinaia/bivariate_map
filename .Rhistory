finalPlot
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 8
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.3
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
setwd("~/Library/CloudStorage/GoogleDrive-quinaiathiago@gmail.com/Meu Drive/thiagoquinaia@edu.uniube.br 2022-05-02 16:52/ACADEMICO/ESTUDOS_R/geoprocessamento/bivariate_map")
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.33
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.35
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.4
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.5
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Definir tamanho base e ajustar dimensões
base_size <- 10
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.5
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 10
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.5
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Definir tamanho base e ajustar dimensões
base_size <- 12
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.5
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Definir tamanho base e ajustar dimensões
base_size <- 8
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.7
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.75, 0.35, 0.25, 0.3) +
# Value legend abaixo (se necessário)
#draw_plot(value_legend, 0.75, 0.05, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.75, 0.35, 0.25, 0.3) +
# Value legend abaixo (se necessário)
#draw_plot(value_legend, 0.75, 0.05, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.75, 0.35, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.65, 0.35, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 8
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.7
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Definir tamanho base e ajustar dimensões
base_size <- 10
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.7
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Definir tamanho base e ajustar dimensões
base_size <- 7
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.7
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 7
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.3
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.7, 0.35, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 7
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.3
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 300,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 400,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_rr.png",
finalPlot,
dpi = 600,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
city <- 'Amapa'
# Filtrar Minas Gerais
mg0 <- br0 %>%
filter(shapeName == city)
# Identificar municípios que intersectam MG
mg1 <- br1 %>%
mutate(
intersects_mg = st_intersects(., mg0) %>% lengths > 0
) %>%
filter(intersects_mg) %>%
mutate(
area_original = st_area(.),
intersecao = st_intersection(., mg0),
area_intersecao = st_area(intersecao)
) %>%
filter(as.numeric(area_intersecao/area_original) > 0.5) %>%
select(-c(area_original, intersecao, area_intersecao, intersects_mg))
# Plotar MG
plot(st_geometry(mg1), border = "gray")
plot(st_geometry(mg0), add = TRUE, border = "black", lwd = 2)
# Retrieve TerraClimate data for the United Kingdom with specified variables (max and min temperature)
temp_terra = getTerraClim(AOI = mg0,
varname = c("tmax", "tmin"),
startDate = "1994-01-01",
endDate  = "2023-12-01")
# Calculate the monthly mean temperature by averaging maximum and minimum temperature
mean_temp_monthly <- (temp_terra$tmax + temp_terra$tmin) / 2
# Calculate the annual mean temperature by averaging the monthly means across all months
annual_mean_temp <- mean(mean_temp_monthly, na.rm = TRUE)
# Plot the annual mean temperature
plot(annual_mean_temp)
# Resample the annual mean temperature raster to a finer resolution (approximately 1 km)
new_res <- 0.025  # Set the new resolution
new_raster <- rast(ext(annual_mean_temp), resolution = new_res, crs = crs(annual_mean_temp))
annual_mean_temp <- resample(x = annual_mean_temp, y = new_raster, method="bilinear")
# Crop the resampled temperature data to match the boundaries of the Brazil
br_temp <- terra::crop(annual_mean_temp, y = mg0, mask = TRUE)
# Plot the cropped annual mean temperature for the Brazil
plot(br_temp)
####### Precipitação ######
# Retrieve TerraClimate data for precipitation in the Brazil
ppt_terra = getTerraClim(AOI = mg0,
varname = "ppt",
startDate = "1994-01-01",
endDate  = "2023-12-01")
# Calculate the annual mean precipitation by averaging the monthly precipitation values across all months
annual_mean_ppt <- mean(ppt_terra$ppt, na.rm = TRUE)
# Resample the annual mean precipitation raster to a finer resolution (approximately 1 km)
new_raster <- rast(ext(annual_mean_ppt), resolution = new_res, crs = crs(annual_mean_ppt))
annual_mean_ppt <- resample(x = annual_mean_ppt, y = new_raster, method = "bilinear")
# Crop the resampled precipitation data to match the boundaries of the United Kingdom
br_ppt <- terra::crop(annual_mean_ppt, y = mg0, mask = TRUE)
# Plot the cropped annual mean precipitation for the United Kingdom
plot(br_ppt)
#### Empilhando Rasters ####
# Combine temperature and precipitation rasters into a single raster stack
temp_ppt <- c(br_temp, br_ppt)
# Assign descriptive names to each raster layer in the stack
names(temp_ppt) <- c("temp", "ppt")
#### Convertendo para Dataframe ####
# Project the combined temperature and precipitation raster stack to match the projection of the UK boundary
# Then convert the raster data to a data frame, retaining the x and y coordinates for mapping
temp_ppt_df <- temp_ppt |>
project(mg0) |>
as.data.frame(xy = TRUE)
# Display the first few rows of the resulting data frame to verify the data
head(temp_ppt_df)
#### Bivariate Map ####
# Classify the temperature and precipitation data into bivariate classes using the 'biscale' package
# 'style = "quantile"' divides data into quantiles, and 'dim = 4' creates 4 classes for each variable, resulting in 16 bivariate categories
data <- bi_class(temp_ppt_df,
x = temp,
y = ppt,
style = "quantile", dim = 4)
# Plot the distribution of the bivariate classes to visualize the frequency of each class
data |>
count(bi_class) |>
ggplot(aes(x = bi_class, y = n)) +
geom_col() +  # Create a bar plot to show the count of each bivariate class
labs(title = "Distribution of Bivariate Classes", x = "Bivariate Class", y = "Frequency")
#### Mapping ####
# Set the color palette for the bivariate map
pallet <- "GrPink2"
# Obter limites com margem
bbox_mg <- st_bbox(mg0)
margin <- 0.5  # margem em graus
# Create the bivariate map using ggplot2
map <- ggplot() +
theme_void(base_size = 14) +  # Set a minimal theme for the map
xlim(bbox_mg[1] - margin, bbox_mg[3] + margin) +  # xmin e xmax com margem
ylim(bbox_mg[2] - margin, bbox_mg[4] + margin) +  # ymin e ymax com margem
# Overlay the country-level boundary of the United Kingdom
geom_sf(data = br0, fill = NA, color = "black", linewidth = 0.40) +
# Overlay the first administrative level boundaries of the Minas Gerais
# Plot the bivariate raster data with appropriate fill color based on bivariate classes
geom_raster(data = data, mapping = aes(x = x, y = y, fill = bi_class), color = NA, linewidth = 0.1, show.legend = FALSE) +
# Overlay the first administrative level boundaries of the Minas Gerais
geom_sf(data = mg1, fill = NA, color = "white", linewidth = 0.05) +
# Apply the bivariate color scale using the selected palette and dimensions
bi_scale_fill(pal = pallet, dim = 4, flip_axes = FALSE, rotate_pal = FALSE) +
# Add labels for the map
labs(title = "Amapá: Padrões de Temperatura e Precipitação",
subtitle = "Média de Temperatura e Precipitação dos últimos 29 anos",
caption = "Fonte: Terra Climate Data - Autor: Thiago Quinaia") +
# Customize the appearance of the title, subtitle, and caption
theme(plot.title = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5),
plot.caption = element_text(size = 9, face = "italic", hjust = 0.5))
# Create the legend for the bivariate map
legend <- bi_legend(pal = pallet,
flip_axes = FALSE,
rotate_pal = FALSE,
dim = 4,
xlab = "Temperatura (Cº)",
ylab = "Precipitação (mm)",
size = 10,
pad_color = "black")
# Combine the map and legend using cowplot
library(cowplot)
# Calcular médias por classe bivariada
class_means <- data %>%
group_by(bi_class) %>%
summarise(
temp_mean = round(max(temp, na.rm = TRUE), 1),
ppt_mean = round(max(ppt, na.rm = TRUE), 1)
)
# Verificar ordenação dos dados
print(data %>%
select(bi_class, temp, ppt) %>%
group_by(bi_class) %>%
summarise(
temp_mean = mean(temp),
ppt_mean = mean(ppt)
) %>%
arrange(bi_class))
# Obter cores da paleta bivariada
bi_colors <- bi_pal(pal = pallet, dim = 4, preview = FALSE)
# Criar dataframe com cores e valores
legend_data <- data.frame(
bi_class = paste(rep(1:4, each=4), rep(1:4, times=4), sep="-"),
x = rep(1:4, each=4),
y = rep(1:4, times=4)
) %>%
left_join(class_means, by="bi_class") %>%
mutate(
fill = bi_colors,
label = paste0("T:", temp_mean, "°C\nP:", ppt_mean, "mm")
)
# Criar nova legenda combinada
value_legend <- ggplot(legend_data, aes(x=y, y=x)) +
geom_tile(aes(fill=fill)) +
geom_label(aes(label=label),
size=2.5,
color="white",
fill="black",
alpha=0.3,        # Transparência do fundo
label.padding=unit(0.1, "lines")) +
scale_fill_identity() +
coord_equal() +
theme_void()
# Modificar o finalPlot para layout sem sobreposição
finalPlot <- ggdraw() +
# Mapa principal ocupando 70% da largura
draw_plot(map, 0, 0, 0.7, 1) +
# Legenda na direita ocupando 30% da largura
draw_plot(legend, 0.7, 0.35, 0.25, 0.3)
# Display the final map with legend
finalPlot
# Calcular proporção do mapa
bbox_width <- bbox_mg[3] - bbox_mg[1]
bbox_height <- bbox_mg[4] - bbox_mg[2]
aspect_ratio <- bbox_width/bbox_height
# Definir tamanho base e ajustar dimensões
base_size <- 7
width <- base_size * aspect_ratio
height <- base_size
# Adicionar espaço para legenda (30% extra na largura)
width_with_legend <- width * 1.3
# Salvar com dimensões apropriadas
ggsave(
"BR_Temp_PPT_amapa.png",
finalPlot,
dpi = 600,
width = width_with_legend,
height = height,
units = "in",
bg = "white",
limitsize = FALSE
)
